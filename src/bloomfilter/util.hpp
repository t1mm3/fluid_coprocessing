#pragma once

#include "constants.hpp"

#include <algorithm>
#include <bitset>
#include <cmath>
#include <dtl/batchwise.hpp>
#include <dtl/dtl.hpp>
#include <functional>
#include <random>
#include <string>
#include <unordered_set>

//===----------------------------------------------------------------------===//
using vector_t = std::vector<uint32_t>;
// using numa_vector_t = std::vector<uint32_t,
// dtl::mem::numa_allocator<uint32_t>>;

// The (static) unrolling factor
constexpr size_t UNROLL_FACTOR = 16;
//===----------------------------------------------------------------------===//

template <class Container> void set_uniform_distributed_values(Container &container) {
	// thread_local allows unique seed for each thread
	thread_local std::random_device rd;     // Will be used to obtain a seed for the random number engine
	thread_local std::mt19937 engine(rd()); // Standard mersenne_twister_engine seeded with rd()

	std::uniform_int_distribution<typename Container::value_type> distribution;
	auto sampler = [&]() { return distribution(engine); }; // Use distribution to transform the random unsigned int
	                                                       // generated by engine into an int in [0, u32]
	std::generate(std::begin(container), std::end(container),
	              sampler); // Initializes the container with random uniform
	                        // distributed values
}

//===----------------------------------------------------------------------===//
namespace internal {

static void gen_random_data(vector_t &data, const std::size_t element_cnt, const bool unique_elements,
                            const std::function<uint32_t()> &rnd) {
	data.clear();
	data.reserve(element_cnt);

	if (unique_elements) { // Generate unique elements.

		if (element_cnt > (1ull << 32)) {
			std::cerr << "Cannot create more than 2^32 unique integers." << std::endl;
			std::exit(1);
		}

		if (element_cnt == (1ull << 32)) {

			// Entire integer domain.
			for (std::size_t i = 0; i < element_cnt; i++) {
				data.push_back(static_cast<uint32_t>(i));
			}
			std::random_device rnd_device;
			std::shuffle(data.begin(), data.end(), rnd_device);

		} else {

			auto is_in_set = new std::bitset<1ull << 32>;
			std::size_t c = 0;
			while (c < element_cnt) {
				auto val = rnd();
				if (!(*is_in_set)[val]) {
					data.push_back(val);
					(*is_in_set)[val] = true;
					c++;
				}
			}
			delete is_in_set;
		}
	} else { // Generate non-unique elements.
		for (std::size_t i = 0; i < element_cnt; i++) {
			data.push_back(rnd());
		}
	}
}

static void gen_random_data_64(std::vector<uint64_t> &data, const std::size_t element_cnt, const bool unique_elements,
                               const std::function<uint64_t()> &rnd) {
	data.clear();
	data.reserve(element_cnt);

	if (unique_elements) { // Generate unique elements.

		if (element_cnt > (1ull << 32)) {
			std::cerr << "Cannot create more than 2^32 unique integers." << std::endl;
			std::exit(1);
		}

		std::unordered_set<uint64_t> set;
		std::size_t c = 0;
		while (c < element_cnt) {
			auto val = rnd();
			if (set.count(val) == 0) {
				data.push_back(val);
				set.insert(val);
				c++;
			}
		}
	} else { // Generate non-unique elements.
		for (std::size_t i = 0; i < element_cnt; i++) {
			data.push_back(rnd());
		}
	}
}

} // namespace internal

enum rnd_engine_t {
	RANDOM_DEVICE,
	MERSENNE_TWISTER,
};

static void gen_data(std::vector<uint32_t> &data, const std::size_t element_cnt, const rnd_engine_t rnd_engine,
                     const bool unique) {

	std::random_device rnd_device;

	switch (rnd_engine) {
	case RANDOM_DEVICE: {
		auto gen_rand = [&rnd_device]() { return static_cast<uint32_t>(rnd_device()); };
		internal::gen_random_data(data, element_cnt, unique, gen_rand);
		break;
	}
	case MERSENNE_TWISTER: {
		auto gen_rand = [&rnd_device]() {
			std::mt19937 gen(rnd_device());
			std::uniform_int_distribution<uint32_t> dis;
			return dis(gen);
		};
		internal::gen_random_data(data, element_cnt, unique, gen_rand);
		break;
	}
	}
}

static void gen_data(std::vector<uint64_t> &data, const std::size_t element_cnt, const rnd_engine_t rnd_engine,
                     const bool unique) {

	std::random_device rnd_device;

	switch (rnd_engine) {
	case RANDOM_DEVICE: {
		auto gen_rand = [&rnd_device]() { return rnd_device() + (static_cast<::std::uint64_t>(rnd_device()) << 32); };
		internal::gen_random_data_64(data, element_cnt, unique, gen_rand);
		break;
	}
	case MERSENNE_TWISTER: {
		std::mt19937_64 gen(rnd_device());
		std::uniform_int_distribution<uint64_t> dis;
		auto gen_rand = [&]() { return dis(gen); };
		internal::gen_random_data_64(data, element_cnt, unique, gen_rand);
		break;
	}
	}
}
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
struct data_generator_64 {

	const rnd_engine_t rnd_engine;
	u1 unique_elements;
	std::unordered_set<uint64_t> set;
	std::function<uint64_t()> rnd_fn;

	data_generator_64(const rnd_engine_t rnd_engine, u1 unique_elements)
	    : rnd_engine(rnd_engine), unique_elements(unique_elements) {

		std::random_device rnd_device;
		std::mt19937_64 gen(rnd_device());
		std::uniform_int_distribution<uint64_t> dis;

		std::function<uint64_t()> rnd = [&rnd_device]() {
			return rnd_device() + (static_cast<::std::uint64_t>(rnd_device()) << 32);
		};

		std::function<uint64_t()> mt = [&]() { return dis(gen); };

		switch (rnd_engine) {
		case RANDOM_DEVICE:
			rnd_fn = rnd;
			break;
		case MERSENNE_TWISTER:
			rnd_fn = mt;
			break;
		}
	}

	uint64_t next() {
		if (unique_elements) { // Generate unique elements.
			while (true) {
				auto val = rnd_fn();
				if (set.count(val) == 0) {
					return val;
				}
			}
		} else { // Generate non-unique elements.
			return rnd_fn();
		}
	}
};
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
struct data_generator_32 {

	u1 unique_elements;
	std::unordered_set<uint32_t> set;

	explicit data_generator_32(u1 unique_elements) : unique_elements(unique_elements){};

	virtual uint32_t next() = 0;
};

struct data_generator_32_rnd : data_generator_32 {

	std::random_device rnd_device;

	explicit data_generator_32_rnd(u1 unique_elements) : data_generator_32(unique_elements) {
	}

	uint32_t next() override {
		if (unique_elements) { // Generate unique elements.
			while (true) {
				auto val = rnd_device();
				if (set.count(val) == 0) {
					return val;
				}
			}
		} else { // Generate non-unique elements.
			return rnd_device();
		}
	}
};

template <class Container> void set_random_values(Container &container) {
	thread_local std::random_device rd;
	thread_local std::mt19937 engine(rd());

	std::uniform_int_distribution<typename Container::value_type> distribution;
	auto sampler = [&]() { return distribution(engine); };
	std::generate(std::begin(container), std::end(container), sampler);
}

struct data_generator_32_mt : data_generator_32 {

	std::random_device rnd_device;
	std::mt19937 gen;
	std::uniform_int_distribution<uint32_t> dis;

	explicit data_generator_32_mt(u1 unique_elements) : data_generator_32(unique_elements), gen(rnd_device()) {
	}

	uint32_t next() override {
		if (unique_elements) { // Generate unique elements.
			while (true) {
				auto val = dis(gen);
				if (set.count(val) == 0) {
					return val;
				}
			}
		} else { // Generate non-unique elements.
			return dis(gen);
		}
	}
};

std::pair<std::string, std::string> split_once(std::string delimited, char delimiter) {
	auto pos = delimited.find_first_of(delimiter);
	return {delimited.substr(0, pos), delimited.substr(pos + 1)};
}

struct params_t {

	// Command-line-settable parameters
	std::string kernel_variant{defaults::kernel_variant};
	bool should_print_results{defaults::should_print_results};
	int num_gpu_streams{defaults::num_gpu_streams};
	cuda::grid_block_dimension_t num_threads_per_block{defaults::num_threads_per_block};
	int num_blocks{defaults::num_blocks};
	int num_query_execution_runs{defaults::num_query_execution_runs};
	bool use_coprocessing{false};
	std::size_t filter_size{defaults::filter_size};
	std::size_t probe_size{defaults::probe_size};
};

params_t parse_command_line(int argc, char **argv) {
	params_t params;
	for (int i = 1; i < argc; i++) {
		auto arg = std::string(argv[i]);
		if (arg.substr(0, 2) != "--") {
			exit(EXIT_FAILURE);
		}
		arg = arg.substr(2);
		auto p = split_once(arg, '=');
		auto &arg_name = p.first;
		auto &arg_value = p.second;
		if (arg_name == "kernel") {
			params.kernel_variant = arg_value;
		} else if (arg_name == "num_blocks") {
			params.num_blocks = std::stoi(arg_value);
		} else if (arg_name == "threads-per-block") {
			params.num_threads_per_block = std::stoi(arg_value);
		} else if (arg_name == "filter_size") {
			params.filter_size = std::stoi(arg_value);
		} else if (arg_name == "probe_size") {
			params.probe_size = std::stoi(arg_value);
		}
	}
	return params;
}
//===----------------------------------------------------------------------===//

/** Zipf-like random distribution.
 *
 * "Rejection-inversion to generate variates from monotone discrete
 * distributions", Wolfgang HÃ¶rmann and Gerhard Derflinger
 * ACM TOMACS 6.3 (1996): 169-184
 */
template <class IntType = unsigned long, class RealType = double> class zipf_distribution {
public:
	typedef RealType input_type;
	typedef IntType result_type;

	static_assert(std::numeric_limits<IntType>::is_integer, "");
	static_assert(!std::numeric_limits<RealType>::is_integer, "");

	zipf_distribution(const IntType n = std::numeric_limits<IntType>::max(), const RealType q = 1.0)
	    : n(n), q(q), H_x1(H(1.5) - 1.0), H_n(H(n + 0.5)), dist(H_x1, H_n) {
	}

	IntType operator()(std::mt19937 &rng) {
		while (true) {
			const RealType u = dist(rng);
			const RealType x = H_inv(u);
			const IntType k = clamp<IntType>(std::round(x), 1, n);
			if (u >= H(k + 0.5) - h(k)) {
				return k;
			}
		}
	}

private:
	/** Clamp x to [min, max]. */
	template <typename T> static constexpr T clamp(const T x, const T min, const T max) {
		return std::max(min, std::min(max, x));
	}

	/** exp(x) - 1 / x */
	static double expxm1bx(const double x) {
		return (std::abs(x) > epsilon) ? std::expm1(x) / x : (1.0 + x / 2.0 * (1.0 + x / 3.0 * (1.0 + x / 4.0)));
	}

	/** H(x) = log(x) if q == 1, (x^(1-q) - 1)/(1 - q) otherwise.
	 * H(x) is an integral of h(x).
	 *
	 * Note the numerator is one less than in the paper order to work with all
	 * positive q.
	 */
	const RealType H(const RealType x) {
		const RealType log_x = std::log(x);
		return expxm1bx((1.0 - q) * log_x) * log_x;
	}

	/** log(1 + x) / x */
	static RealType log1pxbx(const RealType x) {
		return (std::abs(x) > epsilon) ? std::log1p(x) / x : 1.0 - x * ((1 / 2.0) - x * ((1 / 3.0) - x * (1 / 4.0)));
	}

	/** The inverse function of H(x) */
	const RealType H_inv(const RealType x) {
		const RealType t = std::max(-1.0, x * (1.0 - q));
		return std::exp(log1pxbx(t) * x);
	}

	/** That hat function h(x) = 1 / (x ^ q) */
	const RealType h(const RealType x) {
		return std::exp(-q * std::log(x));
	}

	static constexpr RealType epsilon = 1e-8;

	IntType n;                                     ///< Number of elements
	RealType q;                                    ///< Exponent
	RealType H_x1;                                 ///< H(x_1)
	RealType H_n;                                  ///< H(n)
	std::uniform_real_distribution<RealType> dist; ///< [H(x_1), H(n)]
};
