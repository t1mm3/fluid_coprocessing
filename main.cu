#include "hash_table.hpp"
#include "bloomfilter.hpp"
#include "task_manager.hpp"
#include <thrust/host_vector.h>
#include <thrust/device_vector.h>
#include <random>

using filter_key_t = uint32_t;
constexpr size_t TABLE_SIZE = 100;


//===----------------------------------------------------------------------===//
void set_uniform_distributed_values(int32_t* column, size_t range_size) {
    //thread_local allows unique seed for each thread
    thread_local std::random_device rd;     // Will be used to obtain a seed for the random number engine
    thread_local std::mt19937 engine(rd()); //Standard mersenne_twister_engine seeded with rd()

    std::uniform_int_distribution<int32_t> distribution;
    auto sampler = [&]() { return distribution(engine); };   //Use distribution to transform the random unsigned int generated by engine into an int in [0, u32]
    std::generate(&column[0], column + range_size, sampler); // Initializes the container with random uniform distributed values
}
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
void populate_table(Table &table) {
    for(auto &column : table.columns)
        set_uniform_distributed_values((int32_t*)column, table.size());
}
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
int main() {


    TaskManager manager;

    Table table_build(1,TABLE_SIZE);
    populate_table(table_build);

    auto ht = new HashTablinho(4+4*4, 1000);

     //build table
    table_build.chunk([&] (auto columns, auto num_columns, auto offset, auto num) {
        int32_t* tkeys = (int32_t*)columns[0];
        Vectorized::chunk(offset, num, [&] (auto offset, auto num) {
            auto keys = &tkeys[offset];
            uint32_t hashs[num];
            int sel[num];
            Vectorized::map_hash(hashs, keys, sel, num);
            ht->Insert(keys, hashs, sel, num);
        }, kVecSize);

        // FIXME: build bloom filter
    }, [&] () {
        // finished
        ht->FinalizeBuild();
    });

    Table table_probe(1,TABLE_SIZE*10);
    populate_table(table_probe);
    Pipeline pipeline = { {ht}, table_probe};
    manager.execute_query(pipeline);

#ifdef HAVE_CUDA
    // Build 128 bytes Blocked Bloom Filter on CPU
    {
        size_t m = 256*8*1024*1024;
        FilterWrapper filter(m);

        for (std::size_t i = 0; i < table_build.size(); ++i) {
            const auto key = table_build.columns[0] + i;
            filter.insert_with_hash(&filter_data[0], key);
        }

        //execute probe
        manager.execute_query<filter_t, word_t, cuda_probe_t>(Pipeline { {ht}, table_probe}, filter);
    }
#endif
    return 0;
}
//===----------------------------------------------------------------------===//