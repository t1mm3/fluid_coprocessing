#include "hash_table.hpp"
#include "bloomfilter.hpp"
#include "task_manager.hpp"
#include <thrust/host_vector.h>
#include <thrust/device_vector.h>
#include <random>

using filter_key_t = uint32_t;
constexpr size_t TABLE_SIZE = 100;


//===----------------------------------------------------------------------===//
void set_uniform_distributed_values(void *column, size_t range_size) {
    //thread_local allows unique seed for each thread
    thread_local std::random_device rd;     // Will be used to obtain a seed for the random number engine
    thread_local std::mt19937 engine(rd()); //Standard mersenne_twister_engine seeded with rd()

    std::uniform_int_distribution<int32_t> distribution;
    auto sampler = [&]() { return distribution(engine); };   //Use distribution to transform the random unsigned int generated by engine into an int in [0, u32]
    std::generate(&column[0], column + range_size, sampler); // Initializes the container with random uniform distributed values
}
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
void populate_table(Table &table) {
    for(auto &column : table.columns)
        set_uniform_distributed_values(column, table.size());
}
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
int main() {
    TaskManager manager;
    Table table_build(1,TABLE_SIZE);
    populate_table(table_build);

    auto ht = new HashTablinho(4+4*4, 1000);

     //build table
    table_build.chunk([&] (auto columns, auto num_columns, auto offset, auto num) {
        int32_t* tkeys = (int32_t*)columns[0];
        Vectorized::chunk(offset, num, [&] (auto offset, auto num) {
            auto keys = &tkeys[offset];
            uint32_t hashs[num];
            int sel[num];
            Vectorized::map_hash(hashs, keys, sel, num);
            ht->Insert(keys, hashs, sel, num);
        }, kVecSize);

        // FIXME: build bloom filter
    }, [&] () {
        // finished
        ht->FinalizeBuild();
    });

    Table table_probe(1,TABLE_SIZE*10);
    populate_table(table_probe);
    manager.execute_query(Pipeline { {ht}, table_probe});

#ifdef HAVE_CUDA
    // Build 128 bytes Blocked Bloom Filter on CPU
    {
        using filter_t = bbf_t<32, 1, 1, 2>;
        using word_t = typename filter_t::word_t;
        size_t m = 256*8*1024*1024;
        filter_t filter(m);
        word_t *filter_data;

        // Allocate Pinned memory
        size_t filter_bytes = (filter.word_cnt() + 1024) *  sizeof(word_t);
        cudaMallocHost((void**)&filter_data, filter_bytes);

        // TODO build in parallel
        for (std::size_t i = 0; i < table_build.size(); ++i) {
            const auto key = table_build.columns[0];
            filter.insert(&filter_data[0], key);
        }

        //execute probe
        manager.execute_query<filter_t, word_t>(Pipeline { {ht}, table_probe}, filter, filter_data);
    }
#endif
    return 0;
}
//===----------------------------------------------------------------------===//